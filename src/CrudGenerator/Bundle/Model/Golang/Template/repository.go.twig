package repositories

{% set createdField = table.fieldWithName('date_created') %}
{% set updatedField = table.fieldWithName('date_updated') %}
import (
    "{{ config.project.package }}/models"
    "{{ config.project.package }}/modules/context"
    "{{ config.project.package }}/modules/util"
    "{{ config.project.package }}/modules/db"
)

{% set tableName = table.name | upperCamelize %}
{% set tableSingleKey = table.name | slice(0,1) %}
{% set table_name = table.name | underscored %}

//{{ tableName }}Repository ...
type {{ tableName }}Repository struct {
    db.BaseRepository
}


{% set primaryFieldName = golang.primaryName(table.primaryField.name) | upperCamelize  %}
{% set primaryFieldProperty = primaryFieldName  %}
{% set primaryFieldParam = primaryFieldName  %}
{% set primaryFieldType = golang.realType(table.primaryField) %}

//New{{ tableName }}Repository ...
func New{{ tableName }}Repository(ctx context.Base) {{ tableName }}Repository {
    return {{ tableName }}Repository{BaseRepository: db.NewBaseRepository(ctx)}
}

//List ...
func ({{ tableSingleKey }} {{ tableName }}Repository) List(offset, limit int, sort, sortType string) (list models.{{ tableName }}List, err error) {

    cn, err := {{ tableSingleKey }}.DB()
    if err != nil {
        return
    }
    defer {{ tableSingleKey }}.Close()
    sortAllows := map[string]string{
    "{{ table.primaryField.name }}":              "{{ table.primaryField.name }}",
    }

    list = models.{{ tableName }}List{Limit: limit, Offset: offset}
    qb := cn.Model(models.{{ tableName }}{})
    err = qb.
        Order(util.SortValues(sort, sortType, sortAllows)).
        Offset(offset).
        Limit(limit).
        Find(&list.Items).
        Error

    if err != nil {
        return
    }
    err = qb.Count(&list.Total).Error
    if err != nil {
        list.Total = len(list.Items)
    }

    return
}


{% set nameField = table.fieldWithName('name') %}
{% if nameField is not empty %}
//SearchList ...
func ({{ tableSingleKey }} {{ tableName }}Repository) SearchList(query string, offset, limit int) (list models.{{ tableName }}List, err error) {

    cn, err := {{ tableSingleKey }}.DB()
    if err != nil {
        return
    }
    defer {{ tableSingleKey }}.Close()

    list = models.{{ tableName }}List{Limit: limit, Offset: offset}
    qb := cn.Model(models.{{ tableName }}{}).
        Offset(offset).
        Limit(limit).
        Where("{{ nameField.name }} LIKE ?", "%"+query+"%")

    err = qb.Find(&list.Items).
        Error

    if err != nil {
        return
    }
    err = qb.Count(&list.Total).Error
    if err != nil {
        list.Total = len(list.Items)
    }

    return
}
{% endif %}


//FindOneBy{{ primaryFieldProperty }} ...
func ({{ tableSingleKey }} {{ tableName }}Repository) FindOneBy{{ primaryFieldProperty }}({{ primaryFieldParam }} {{ primaryFieldType }}) (*models.{{ tableName }}, error) {
    return {{ tableSingleKey }}.FindOne("{{ table.primaryField.name }} = ?",{{ primaryFieldParam }})
}


{% if nameField is not empty %}
{% set nameFieldName = nameField.name | upperCamelize  %}
{% set nameFieldProperty = nameFieldName  %}
{% set nameFieldParam = nameFieldName | camelize  %}
{% set nameFieldType = golang.type(nameField) %}
//FindOneBy{{ nameFieldProperty }} ...
func ({{ tableSingleKey }} {{ tableName }}Repository) FindOneBy{{ nameFieldProperty }}({{ nameFieldParam }} {{ nameFieldType }}) (*models.{{ tableName }}, error) {
    return {{ tableSingleKey }}.FindOne("{{ nameField.name }} = ?",{{ nameFieldParam }})
}
{% endif %}
//Create ...
func ({{ tableSingleKey }} {{ tableName }}Repository) Create(object models.{{ tableName }}) (*models.{{ tableName }}, error) {

    cn, err := {{ tableSingleKey }}.DB()
    if err != nil {
        return nil,err
    }
    defer {{ tableSingleKey }}.Close()

    err = cn.Create(&object).Error
    if err != nil {
        return
    }

    return &object,nil

}

//Update ...
func ({{ tableSingleKey }} {{ tableName }}Repository) Update(object models.{{ tableName }}, data interface{}) (err error) {
    values := {{ tableSingleKey }}.DiffStruct(&object, data)
    return {{ tableSingleKey }}.UpdateColumns(object, values)
}

//UpdateColumns ...
func ({{ tableSingleKey }} {{ tableName }}Repository) UpdateColumns(object models.{{ tableName }}, values interface{}) (err error) {

    cn, err := {{ tableSingleKey }}.DB()
    if err != nil {
        return
    }
    defer {{ tableSingleKey }}.Close()

    err = cn.Model(&object).Updates(values).Error
    if err != nil {
        return
    }

    return
}

//UpdateSingle ...
func ({{ tableSingleKey }} {{ tableName }}Repository) UpdateSingle(object models.{{ tableName }}, column string, value interface{}) (err error) {

    cn, err := {{ tableSingleKey }}.DB()
    if err != nil {
        return
    }
    defer {{ tableSingleKey }}.Close()

    err = cn.Model(&object).Update(column, value).Error
    if err != nil {
        return
    }

    return
}

//Delete ...
func ({{ tableSingleKey }} {{ tableName }}Repository) Delete(object models.{{ tableName }}) (err error) {

    cn, err := {{ tableSingleKey }}.DB()
    if err != nil {
        return
    }
    defer {{ tableSingleKey }}.Close()

    err = cn.Where("{{ table.primaryField.name }} = ? ", object.{{ primaryFieldProperty }}).Delete(object).Error
    if err != nil {
        return
    }
    return
}

//FindOne ...
func ({{ tableSingleKey }} {{ tableName }}Repository) FindOne(query interface{}, args ...interface{}) (*models.{{ tableName }}, error) {

    cn, err := {{ tableSingleKey }}.DB()
    if err != nil {
        return nil, err
    }
    defer {{ tableSingleKey }}.Close()

    var result models.{{ tableName }}
    err = cn.Where(query, args...).First(&result).Error
    if err != nil {
        return
    }
    return &result, nil
}
