//Package controllers ...
package controllers

import (
    "fmt"
    "net/http"
    "github.com/kataras/iris"
    "{{ config.project.package }}/controllers/middleware"
    "{{ config.project.package }}/models"
    "{{ config.project.package }}/repositories"
)

{% set tableName = table.name | upperCamelize %}
{% set tableSingleKey = table.name | slice(0,1) %}
{% set table_name = table.name | underscored | replace({'_':'-'}) %}

{% set nameField = table.fieldWithName('name') %}

//{{ tableName }}Controller ...
func {{ tableName }}Controller(app *iris.Application) {

    app.Get("/{{ table_name }}",
        middleware.Database,
        //middleware.JWT.Serve,
        middleware.Permissions{Permissions: []string{"{{ table_name }}_read"}}.Serve,
        middleware.Log,
        func(ctx iris.Context) {

        request := NewRequest(ctx)
        limit, _ := request.GetURLParamInt("limit")
        offset, _ := request.GetURLParamInt("offset")
        {% if nameField is not empty %}
        query := request.GetURLParam("query")
        {% endif %}
        sort := request.GetURLParam("sort")
        sortType := request.GetURLParam("sort_type")
        repo := repositories.New{{ tableName }}Repository(ctx)

        var err error
        var result models.{{ tableName }}List

        {% if nameField is not empty %}
        if query != "" {
            result, err = repo.SearchList(query, offset, limit)
        } else {
            result, err = repo.List(offset, limit, sort, sortType)
        }
        {% else %}
            result, err = repo.List(offset, limit, sort, sortType)
        {% endif %}
        if err != nil {
            request.SendError(http.StatusInternalServerError,err)
            return
        }

        request.Header("X-Total", fmt.Sprint(result.Total))
        request.Header("X-Offset", fmt.Sprint(result.Offset))
        request.Header("X-Limit", fmt.Sprint(result.Limit))
        request.SendResponse(http.StatusOK,result)

    })

{% set primaryFieldName = golang.primaryName(table.primaryField.name) | camelize  %}
{% set primaryFieldProperty = primaryFieldName | upperCamelize  %}
{% set primaryFieldParam = table.primaryField.name | camelize %}
{% set primaryFieldType = golang.realType(table.primaryField) %}
{% set primaryFieldTypeRoute = primaryFieldType | replace({'64':''}) %}

    app.Get("/{{ table_name }}/{{ '{' }}{{ primaryFieldParam }}:{{ primaryFieldTypeRoute }} min(1){{ '}' }}",
        middleware.Database,
        //middleware.JWT.Serve,
        middleware.Permissions{Permissions: []string{"{{ table_name }}_read"}}.Serve,
        middleware.Log,
        func(ctx iris.Context) {

        request := NewRequest(ctx)
        id, _ := request.GetParam{{ primaryFieldType | upperCamelize }}("{{ primaryFieldParam }}")

        repo := repositories.New{{ tableName }}Repository(ctx)
        item, err := repo.FindOneBy{{ primaryFieldProperty }}(id)
        if err != nil {
            request.SendError(http.StatusNotFound,err)
            return
        }

        request.SendResponse(http.StatusOK,item)

    })


    app.Post("/{{ table_name }}",
        middleware.Database,
        //middleware.JWT.Serve,
        middleware.Permissions{Permissions: []string{"{{ table_name }}_write"}}.Serve,
        middleware.Log,
        func(ctx iris.Context) {

        request := NewRequest(ctx)
        formData := models.{{ tableName }}{}
        err := request.ReadForm(&formData)
        if err != nil {
            request.SendError(http.StatusBadRequest,err)
            return
        }
        err = formData.IsValid()
        if err != nil {
            request.SendError(http.StatusBadRequest, err)
            return
        }
        item := models.{{ tableName }}{}
        itemBinded := request.BindRequest(item, formData)

        repo := repositories.New{{ tableName }}Repository(ctx)
        result, err := repo.Create(itemBinded.(models.{{ tableName }}))
        if err != nil {
            request.SendError(http.StatusInternalServerError,err)
            return
        }
        request.SendResponse(http.StatusOK,result)

    })

    app.Put("/{{ table_name }}/{{ '{' }}{{ primaryFieldParam }}:{{ primaryFieldTypeRoute }} min(1){{ '}' }}",
        middleware.Database,
        //middleware.JWT.Serve,
        middleware.Permissions{Permissions: []string{"{{ table_name }}_write"}}.Serve,
        middleware.Log,
        func(ctx iris.Context) {

        request := NewRequest(ctx)
        repo := repositories.New{{ tableName }}Repository(ctx)
        id, _ := request.GetParam{{ primaryFieldType | upperCamelize }}("{{ primaryFieldParam }}")
        item, err := repo.FindOneBy{{ primaryFieldProperty }}(id)
        if err != nil {
            request.SendError(http.StatusNotFound,err)
            return
        }

        formData := models.{{ tableName }}{}
        err = request.ReadForm(&formData)
        if err != nil {
            request.SendError(http.StatusBadRequest,err)
            return
        }
        err = formData.IsValid()
        if err != nil {
            request.SendError(http.StatusBadRequest, err)
            return
        }
        itemBinded := request.BindRequest(item, formData)

        result, err := repo.Update(item,itemBinded)
        if err != nil {
            request.SendError(http.StatusInternalServerError,err)
            return
        }
        request.SendResponse(http.StatusOK,result)

    })

    app.Delete("/{{ table_name }}/{{ '{' }}{{ primaryFieldParam }}:{{ primaryFieldTypeRoute }} min(1){{ '}' }}",
        middleware.Database,
        //middleware.JWT.Serve,
        middleware.Permissions{Permissions: []string{"{{ table_name }}_write"}}.Serve,
        middleware.Log,
        func(ctx iris.Context) {

        request := NewRequest(ctx)
        repo := repositories.New{{ tableName }}Repository(ctx)
        id, _ := request.GetParam{{ primaryFieldType | upperCamelize }}("{{ primaryFieldParam }}")
        item, err := repo.FindOneBy{{ primaryFieldProperty }}(id)
        if err != nil {
            request.SendError(http.StatusNotFound,err)
            return
        }

        err = repo.Delete(item)
        if err != nil {
            request.SendError(http.StatusInternalServerError,err)
            return
        }

        request.SendResponse(http.StatusOK,item)

    })
}
